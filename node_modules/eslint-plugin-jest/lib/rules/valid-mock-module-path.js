"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _fs = require("fs");
var _path = _interopRequireDefault(require("path"));
var _utils = require("@typescript-eslint/utils");
var _utils2 = require("./utils");
function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }
var _default = exports.default = (0, _utils2.createRule)({
  name: __filename,
  meta: {
    type: 'problem',
    docs: {
      description: 'Disallow mocking of non-existing module paths'
    },
    messages: {
      invalidMockModulePath: 'Module path {{ moduleName }} does not exist or is not exported'
    },
    schema: [{
      type: 'object',
      properties: {
        moduleFileExtensions: {
          type: 'array',
          items: {
            type: 'string'
          },
          additionalItems: false
        }
      },
      additionalProperties: false
    }]
  },
  defaultOptions: [{
    moduleFileExtensions: ['.js', '.ts', '.tsx', '.jsx', '.json']
  }],
  create(context, [{
    moduleFileExtensions = ['.js', '.ts', '.tsx', '.jsx', '.json']
  }]) {
    return {
      CallExpression(node) {
        if (node.callee.type !== _utils.AST_NODE_TYPES.MemberExpression) {
          return;
        }
        if (!node.arguments.length || !(0, _utils2.isTypeOfJestFnCall)(node, context, ['jest']) || !((0, _utils2.isSupportedAccessor)(node.callee.property) && ['mock', 'doMock'].includes((0, _utils2.getAccessorValue)(node.callee.property)))) {
          return;
        }
        const moduleName = (0, _utils2.findModuleName)(node.arguments[0]);
        if (!moduleName) {
          return;
        }
        try {
          if (!moduleName.value.startsWith('.')) {
            require.resolve(moduleName.value);
            return;
          }
          const resolvedModulePath = _path.default.resolve(_path.default.dirname(context.filename), moduleName.value);
          const hasPossiblyModulePaths = ['', ...moduleFileExtensions].some(ext => {
            try {
              (0, _fs.statSync)(`${resolvedModulePath}${ext}`);
              return true;
            } catch {
              return false;
            }
          });
          if (hasPossiblyModulePaths) {
            return;
          }
        } catch (err) {
          const castedErr = err;

          // Reports unexpected issues when attempt to verify mocked module path.
          // The list of possible errors is non-exhaustive.
          if (castedErr.code !== 'MODULE_NOT_FOUND' && castedErr.code !== 'ERR_PACKAGE_PATH_NOT_EXPORTED') {
            throw new Error(`Error when trying to validate mock module path from \`jest.mock\`: ${err}`);
          }
        }
        context.report({
          messageId: 'invalidMockModulePath',
          data: {
            moduleName: moduleName.raw
          },
          node
        });
      }
    };
  }
});